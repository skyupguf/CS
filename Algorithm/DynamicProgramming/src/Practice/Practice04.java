package Practice;
// Practice4
// 배낭에 물품을 담으려고 한다.
// 배낭에는 k 무게 만큼의 물품을 담을 수 있다.
// n 개의 물품이 주어지고 이 물품의 무게와 가치 정보가 items 2차원 배열에 주어졌을 때,
// 최대 가치가 되도록 물품을 담았을 때의 가치를 출력하는 프로그램을 작성하세요.

// 입출력 예시
// items: {{6, 13}, {4, 8}, {3, 6}, {5, 10}, {1, 3}}
// n: 5
// k: 8
// 출력: 17
/*
*   풀이
*   각 무게를 열로 하는 n개의 품목행을 가진 dp 2차원 배열을 생성한다.
*   이렇게 하면 물건이 추가될 때마다 현재 무게의 최대가치를 누적해서 기록할 수 있다.
*
*   기록 과정
*   1. (무게 6, 가치 13) 은 물건 1개이므로 무게 6이전 모든 값은 0이 된다.
*       1-1. 무게 6이면 물건 1개이므로 현재 가치인 13이 최대 가치가 되고 7, 8 일 때도 13이 된다.
*   2. (무게 4, 가치 8) 은 이제 물건 2개가 되므로 이전 무게에서 구해놓은 무게 당 최대가치와 비교해야 한다.
*       2-1. 무게 4가 되기전 까지 전부 0이다.
*       2-2. 무게 4가 되면 무게 4에서 만들 수 있는 최대가치를 구해야 한다.
*           2-2-a. 이전에 기록된 무게 4의 최대가치와 현재가치 8 + 0((현재무게(4) - 물건무게(4))의 위치 가치) 중 큰 가치를 기록한다.
*       2-3. 2-2과정을 4이후 부터 모두 수행하면 물건 2개일 때 각 무게에서 현재까지 최대가치를 구할 수 있다.
*   3. 2의 과정을 마지막 물건이 추가될 때까지 반복 수행하면 마지막 행의 각 무게 인덱스에 해당 무게일 때 최대가치가 기록된다.

     0  1  2  3  4  5  6  7  8
    [0, 0, 0, 0, 0,  0,  0,  0,  0]
    [0, 0, 0, 0, 0,  0, 13, 13, 13]
    [0, 0, 0, 0, 8,  8, 13, 13, 13]
    [0, 0, 0, 6, 8,  8, 13, 14, 14]
    [0, 0, 0, 6, 8, 10, 13, 14, 16]
    [0, 3, 3, 6, 9, 11, 13, 16, 17]

*   무게 1 물건의 가치는 3이며, 무게 2 물건이 없으므로 무게 2까지 최대가치는 3이다.
*   무게 3 물건의 가치는 6이며, 다른 물건들을 더해도 3을 만들 수 없으므로 6이 최대 가치가 된다.
*   무게 4 물건의 가치는 8이지만, 무게3과 무게1 물건의 가치가 9이므로 무게 4의 최대 가치는 9가 된다.
*   무게 5 물건의 가치는 10이지만, 무게4와 무게1 물건의 가치가 11이므로 무게 5의 최대 가치는 11이 된다.
*   무게 6 물건의 가치는 13이고, 무게5와 무게1 역시 13이므로 무게 5의 최대 가치는 13이 된다.
*   무게 7 물건은 존재하지 않고, 무게6과 무게1이 16이 되므로 무게 7의 최대 가치는 16이 된다.
*   무게 8 물건은 존재하지 않고, 무게4, 무게3, 무게1이 17이 되므로 무게 8의 최대 가치는 17이 된다.
* */

public class Practice04 {

    public static int solution(int[][] items, int n, int k) {
        int[][] dp = new int[n+1][k+1];

        int i = 1;
        for (int[] item : items) {
            int W = item[0];
            int V = item[1];

            for (int j = 1; j <= k; j++) {
                //  현재 물건개수 기준 각 무게(j)에서 최대 가치를 기록해야 한다.
                dp[i][j] = W > j ? dp[i-1][j] : Math.max(dp[i-1][j], dp[i-1][j-W] + V);
            }
            ++i;
        }
        return dp[n][k];
    }


    public static void main(String[] args) {
        // Test code
        int[][] items = {{6, 13}, {4, 8}, {3, 6}, {5, 12}};
        System.out.println(solution(items, 4, 7));  // 14

        items = new int[][] {{6, 13}, {4, 8}, {3, 6}, {5, 12}, {1, 2}};
        System.out.println(solution(items, 5, 7));  // 15

        items = new int[][] {{6, 13}, {4, 8}, {3, 6}, {5, 10}, {1, 3}};
        System.out.println(solution(items, 5, 8));  // 17
    }
}
